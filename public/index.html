<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>St. Pauli school of TDD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/asciinema-player.css">
  <link rel="alternate" type="application/json+oembed" href="https://tddstpau.li/oembed.json">
</head>

<body>
  <div class="navbar navbar-expand-lg fixed-bottom navbar-dark bg-primary">
    <div class="container">
      <a href="index.html" class="navbar-brand">St. Pauli school of TDD</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive"
        aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="#rationale">Rationale</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#approach">Approach</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#comparison">Comparison</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#demo">Demo</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#faq">FAQ</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#sponsor">Sponsor</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="privacy.html">Privacy</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="imprint.html">Imprint</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <div class="main container">
    <div class="row">
      <div class="col-lg-12">
        <div class="jumbotron">
          <h1 class="display-3">St. Pauli school of TDD</h1>
          <hr class="my-4">
          <p class="lead">A systematic approach to Test-driven Development that leads to continuous progress</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-6">
        <h2 id="rationale">Rationale</h2>
        <p scope="col">Test-driven development is designed to provide feedback at intervals of seconds or minutes on
          whether current software development is making progress in the right direction. If the development takes too
          long until all tests can be run again without errors, this feedback is missing and a slower development speed
          is the result. We often notice that many developers are still able to handle the first two or three TDD cycles
          smoothly, but the subsequent cycles are so slow that one can hardly speak of test-driven development. We have
          therefore developed a systematic approach that leads to continuous progress in short TDD cycles. Following the
          two well-known TDD approaches - "Chicago school" and "London school" - we have named this approach St. Pauli
          school of TDD.</p>

      </div>
      <div class="col-lg-6">
        <h2 id="approach">Approach</h2>
        <div id="accordion">
          <div class="card">
            <div class="card-header bg-primary" id="start-with-api">
              <h5 class="mb-0">
                <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#start-with-api-description"
                  aria-expanded="false" aria-controls="start-with-api-description">
                  Start on the API-level
                </button>
              </h5>
            </div>

            <div id="start-with-api-description" class="collapse" aria-labelledby="start-with-api">
              <div class="card-body">
                Start with a simple test at the API-level of your Subject under Test (SUT).
              </div>
            </div>
          </div>
          <div class="card">
            <div class="card-header bg-primary" id="grow-steady">
              <h5 class="mb-0">
                <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#grow-steady-description"
                  aria-expanded="false" aria-controls="grow-steady-description">
                  Grow slow and steady
                </button>
              </h5>
            </div>
            <div id="grow-steady-description" class="collapse" aria-labelledby="grow-steady">
              <div class="card-body">
                Enter the <a href="https://www.jamesshore.com/Blog/Red-Green-Refactor.html">Red-Green-Refactor-Cycle</a>
                to grow tests and implementation slow and steady by
                <a href="http://blog.baudson.de/blog/test-driven-development-green-bar-patterns">writing the obvious
                  implementation, fake it 'till you make it and triangulate.</a>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="card-header bg-primary" id="no-mocks-but-stubs">
              <h5 class="mb-0">
                <button class="btn btn-link collapsed" data-toggle="collapse"
                  data-target="#no-mocks-but-stubs-description" aria-expanded="false"
                  aria-controls="no-mocks-but-stubs-description">
                  Delegate subproblems to stubs
                </button>
              </h5>
            </div>
            <div id="no-mocks-but-stubs-description" class="collapse" aria-labelledby="no-mocks-but-stubs">
              <div class="card-body">
                Without using mocks, work from the outside to the inside of your SUT.
                Reduce the scope of a SUT by using stubs that pretend to have solved one or more
                subtasks of the SUT.
              </div>
            </div>
          </div>
          <div class="card">
            <div class="card-header bg-primary" id="replace-stubs-recursively">
              <h5 class="mb-0">
                <button class="btn btn-link collapsed" data-toggle="collapse"
                  data-target="#replace-stubs-recursively-description" aria-expanded="false"
                  aria-controls="replace-stubs-recursively-description">
                  Replace stubs recursively
                </button>
              </h5>
            </div>
            <div id="replace-stubs-recursively-description" class="collapse"
              aria-labelledby="replace-stubs-recursively">
              <div class="card-body">If there are stubs in the SUT, replace the stubs with their
                real implementation by making them the new SUT and go to <a href="#start-with-api">Start on the
                  API-level</a>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="card-header bg-primary" id="add-validation-test">
              <h5 class="mb-0">
                <button class="btn btn-link collapsed" data-toggle="collapse"
                  data-target="#add-validation-test-description" aria-expanded="false"
                  aria-controls="add-validation-test-description">
                  Finish off with a validation test
                </button>
              </h5>
            </div>
            <div id="add-validation-test-description" class="collapse" aria-labelledby="add-validation-test">
              <div class="card-body">
                Always add a validation test after each SUT has been finished to
                avoid overfitting to the training set that you used to develop the SUT.
              </div>
            </div>
          </div>
          <div class="card">
            <div class="card-header bg-primary" id="append-only-test-suite">
              <h5 class="mb-0">
                <button class="btn btn-link collapsed" data-toggle="collapse"
                  data-target="#append-only-test-suite-description" aria-expanded="false"
                  aria-controls="append-only-test-suite-description">
                  Treat test suite as append-only
                </button>
              </h5>
            </div>
            <div id="append-only-test-suite-description" class="collapse" aria-labelledby="append-only-test-suite">
              <div class="card-body">
                During development, treat your suit of tests as append-only. Do not delete or
                comment out a test that is formally correct, but conflicts with your current development state. If you
                painted yourself into a corner, instead revert to a state where you can make continuous progress again.
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <h4 id="comparison">Comparison to other schools of TDD</h4>
        <p scope="row">All schools formulate an opinion on three common aspects:</p>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12 d-md-none d-block d-md-none">
        <table class="table table-hover">
          <thead>
            <tr class="table-primary">
              <th scope="col">School</th>
              <th scope="col">St. Pauli</th>
              <th scope="col"><a
                  href="https://github.com/testdouble/contributing-tests/wiki/Detroit-school-TDD">Detroit</a></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th scope="row">Direction</th>
              <td>Outside-In</td>
              <td>Inside-Out</td>
            </tr>
            <tr>
              <th scope="row">First Test Case</th>
              <td>Simple</td>
              <td>Simple</td>
            </tr>
            <tr>
              <th scope="row">Use of Mocks</th>
              <td>avoid</td>
              <td>avoid</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="col-lg-12 d-md-none d-block d-md-none">
        <table class="table table-hover">
          <thead>
            <tr class="table-primary">
              <th scope="col">School</th>
              <th scope="col"><a
                  href="https://github.com/testdouble/contributing-tests/wiki/London-school-TDD">London</a></th>
              <th scope="col"><a href="https://de.slideshare.net/davidvoelkel/fake-it-outsidein-tdd-xp2017">Munich</a>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th scope="row">Direction</th>
              <td>Outside-In</td>
              <td>Outside-In</td>
            </tr>
            <tr>
              <th scope="row">First Test Case</th>
              <td>Simple</td>
              <td>Complex</td>
            </tr>
            <tr>
              <th scope="row">Use of Mocks</th>
              <td>embrace</td>
              <td>avoid</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="col-lg-12 d-none d-md-block">
        <table class="table table-hover">
          <thead>
            <tr class="table-primary">
              <th scope="col">School</th>
              <th scope="col">St. Pauli</th>
              <th scope="col"><a
                  href="https://github.com/testdouble/contributing-tests/wiki/Detroit-school-TDD">Detroit</a></th>
              <th scope="col"><a
                  href="https://github.com/testdouble/contributing-tests/wiki/London-school-TDD">London</a></th>
              <th scope="col"><a href="https://de.slideshare.net/davidvoelkel/fake-it-outsidein-tdd-xp2017">Munich</a>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th scope="row">Direction</th>
              <td>Outside-In</td>
              <td>Inside-Out</td>
              <td>Outside-In</td>
              <td>Outside-In</td>
            </tr>
            <tr>
              <th scope="row">First Test Case</th>
              <td>Simple</td>
              <td>Simple</td>
              <td>Simple</td>
              <td>Complex</td>
            </tr>
            <tr>
              <th scope="row">Use of Mocks</th>
              <td>avoid</td>
              <td>avoid</td>
              <td>embrace</td>
              <td>avoid</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <p scope="row">As shown above, the St. Pauli school of TDD differs in 1 out of 3 aspects from every other
          school.
        </p>
        <p scope="row">Besides these aspects, the St. Pauli school has two requirements, which are not integral part
          of
          the other schools:</p>
        <ul>
          <li><a href="#add-validation-test">Always add a validation test after each SUT has been finished</a></li>
          <li><a href="#append-only-test-suite">During development, treat your suit of tests as append-only</a></li>
        </ul>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <h2 id="demo">Demo</h2>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <asciinema-player src="/casts/diamond-kata.cast" speed="2.0" cols="141" rows="37" theme="solarized-light"
          poster="data:text/plain,Diamond Kata solved with St. Pauli-style TDD"></asciinema-player>
        <a class="btn btn-primary" data-toggle="collapse" href="#commentary" role="button" aria-expanded="false"
          aria-controls="commentary">
          Show commentary
        </a>
        <div class="collapse" id="commentary">
          <table class="table table-hover">
            <thead>
              <tr class="table-primary">
                <th scope="col">Timestamp</th>
                <th scope="col">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>00:00</td>
                <td>We start with a new Clojure project. We choose Clojure, because it has minimal syntax and has a high
                  signal-vs-noise-ratio. It is also very readable once you are familiar with f(x) is written (f x).</td>
              </tr>
              <tr>
                <td>00:36</td>
                <td>We enter the first TDD cycle with a failing (red) test, that has been auto-generated by the Clojure
                  build tool. We are therefore in the red state.</td>
              </tr>
              <tr>
                <td>00:40</td>
                <td>To get as quickly as possible into the green state, we assert that 0 is indeed 0. This is not very
                  useful, but we are just warming up.</td>
              </tr>
              <tr>
                <td>00:59</td>
                <td>The first step of the St. Pauli school of TDD is to start with a simple API test. So we change the
                  test's name and specify the API of the diamond function. We already made some design decisions there:
                  The input of the function should be a single character, the output should be a vector containing a
                  string for each line and the function name should be “diamond”. Since a function with this name does
                  not exist yet, The test runner prints an error and I am back in the red state.</td>
              </tr>
              <tr>
                <td>01:10</td>
                <td>To make some progress towards the green state, we write a minimal implementation of the diamond
                  function. The macro (a special kind of function) defn creates a new function with the name specified
                  by the first argument to defn (here: diamond). The second argument to defn is a vector of all the
                  arguments of the function. There is only one argument of the diamond function and it is named $char.
                  The $ sign has no special meaning, we just use it to prefix the variable name since there is already a
                  char function provided by Clojure. Since the diamond function does not return anything, we are still
                  in the red state, but now the test result is much more helpful:</td>
              </tr>
              <tr>
                <td>
                  <code</td> <td>expected: (= ["a"] (diamond \a)), actual: (not (= ["a"] nil))</code>
                </td>
              </tr>
              <tr>
                <td>That </td>
                <td>eans, (diamond \a) should return ["a”], but it returns nil, and nil is not ["a"]. </td>
              </tr>
              <tr>
                <td>01:13</td>
                <td>The quickest way to get back in the green state is to return the expected value [“a”]. This is both
                  part of the “Fake-it”(http://wiki.c2.com/?FakeIt)- and the
                  “Triangulate”(http://wiki.c2.com/?TriangulateToDesign)-Pattern. If we refactor the constant value to
                  the real implementation, we would have used the “Fake-it”(http://wiki.c2.com/?FakeIt)-Pattern. But
                  this would be a to big step at this point. That is why we continue with the
                  “Triangulate”(http://wiki.c2.com/?TriangulateToDesign)-Pattern. With this pattern, we add more tests
                  until returning hard coded answers gets ridiculous and the real implementation gets more obvious.</td>
              </tr>
              <tr>
                <td>02:59</td>
                <td>The macro cond is similar to a switch statement in in other languages. Depending on the variable
                  $char, it returns different hard-coded vectors. There are now three tests and a structure is emerging.
                  That is why we continue with the second part of the “Fake-It” Pattern and refactor the hard coded pard
                  in small steps towards the real implementation.</td>
              </tr>
              <tr>
                <td>03:08</td>
                <td>We replace the hard-coded vector ["__a__" "_b_b_" "c___c" "_b_b_" "__a__"] with the result of (into
                  ["__a__" "_b_b_" "c___c" "_b_b_" "__a__"]). Since into called with only one argument returns that same
                  argument, this change qualifies as a refactoring, because the internal structure of diamond has been
                  changed but the visible result is the same.</td>
              </tr>
              <tr>
                <td>3:15 </td>
                <td>nto can also be called with two collections as arguments. In that case, into returns the first
                  collection with all elements of the second collection included. We take the next tiny step and call
                  into with the same vector and an empty vector. Unsurprisingly, this does also not change the result,
                  but is a little bit closer to the real implementation.</td>
              </tr>
              <tr>
                <td>3:23 </td>
                <td>ere, we split the first vector in two parts and call into with them. We are still in the green
                  state, but now we can see a possibility to reduce the problem. The second vector can be derived from
                  the first vector if we remove the first vector’s last element and reverse it afterwards.</td>
              </tr>
              <tr>
                <td>3:38 </td>
                <td>oth vectors are still independent from each other, but we already remove the last element of the
                  second vector without breaking any tests by adding a neutral element at the end. Except for the fact
                  that it gets removed, this element can be ignored (hence the name).</td>
              </tr>
              <tr>
                <td>3:54 </td>
                <td>t this point, to introduce the reversing of the second vector in a non-breaking way, we need to
                  switch the first and the second element of the second vector before surrounding it with the reverse
                  function.</td>
              </tr>
              <tr>
                <td>04:25</td>
                <td>With the let macro we are able to define local variables. We call it $pyramid, because the shape of
                  the vector we assign to the variable looks like a pyramid. At first, we just define the variable
                  without using it anywhere. With all this small steps we can be pretty sure to stay on the
                  “green-path”.</td>
              </tr>
              <tr>
                <td>04:32</td>
                <td>Now we replace the first occurrence of the pyramid with the variable.</td>
              </tr>
              <tr>
                <td>04:39</td>
                <td>And now the second occurrence.</td>
              </tr>
              <tr>
                <td>04:48</td>
                <td>Here we paste a prepared todo function into the project. The todo function can be called with
                  arbitrary arguments (marked by the & sign), which can be accessed within the function body as a list
                  called args. The todo function will always return the last argument.</td>
              </tr>
              <tr>
                <td>04:58</td>
                <td>We delegate the responsibility of the subproblem to construct a pyramid to a function called
                  pyramid, that does not exist yet, but that we would like to have. We wrap it within the todo function,
                  where we state what the pyramid function would return. Since we are not sure yet with which arguments
                  I should call this new function, we just call it here with the single argument :todo. This name
                  signals to us, that we have come back here later and make a decision. We can be sure, that writing
                  tests for pyramid first will guide us to come up with a good API for that function.</td>
              </tr>
              <tr>
                <td>05:59</td>
                <td>The St. Pauli school of TDD defines a recursive approach. The pyramid function is now the new SUT
                  and we start again with a most basic API-test. We deliberately chose a different test input than in
                  the diamond context to not overfit the design of the pyramid function of its usage in the diamond
                  context. We decide that the pyramid function should have a start and an end parameter. The top of the
                  resulting pyramid should be the defined by the start argument and the base of the pyramid by the end
                  argument. The height and width of the pyramid can then be calculated by the distance between the start
                  and end argument. Since the pyramid function does not yet exist, we are now in the red state.</td>
              </tr>
              <tr>
                <td>06:10</td>
                <td>Similar to the diamond function, we only implement the function signature without returning anything
                  to get clear feedback what the test is expecting and what is still missing. Then we continue with the
                  triangulate pattern to get back in the green state and learn more about the behaviour of the pyramid
                  function.</td>
              </tr>
              <tr>
                <td>07:45</td>
                <td>Again, three test are sufficient to notice a pattern. If the distance between the start and the end
                  argument increases by one, one more argument is appended to the vector and all existing arguments are
                  surrounded by one more underscore character. For example, given a pyramid with three lines, the top
                  line has two underscores at the front and two at the back, the middle line has one underscore at the
                  front and one at the back and the bottom line has no underscores at the front or at the back. If we
                  start constructing the pyramid with the top line and surround each line of the pyramid with
                  underscores when we add another line to the pyramid, we create this distinguished shape. How can we
                  iteratively construct the pyramid then? First we need to know, how to append an element to a vector in
                  Clojure. This is accomplished with conj: (conj [] 1) results in [1]. To add multiple lines to a vector
                  we can use the reduce function: The result of (reduce + 0 [1 2 3]) is 6 and the result of (reduce conj
                  [] [1 2 3]) is [1 2 3]). That means, exchanging the vector [“__x__” “_y_y_” “z___z”] with (reduce conj
                  [][“__x__” “_y_y_” “z___z”]) is getting us closer to the real iterative construction of the pyramid
                  without changing the behaviour of the pyramid function. In this way, we are both making progress and
                  stay in the green state.</td>
              </tr>
              <tr>
                <td>08:25</td>
                <td>Instead of calling reduce with the conj function directly, we introduce now an indirection and call
                  reduce with a function, that delegates to the conj function. Still, no change of visible behaviour and
                  still in the green state.</td>
              </tr>
              <tr>
                <td>08:31</td>
                <td>In line 18, we map over each line in pyramid and call the identity function, which returns exactly
                  the argument that it was called with: (mapv identity [1 2 3]) returns [1 2 3] and (mapv identity [“a”
                  “b”]) returns [“a” “b”]) We use the function mapv instead of the map function, because a pyramid is a
                  vector and mapv returns a vector (map returns a sequence).</td>
              </tr>
              <tr>
                <td>08:42</td>
                <td>To prepare for the underscore-surrounding logic, the next little step is to inline the identity
                  function (the parameter name p does not fit well, though: Because a pyramid consists of lines, the
                  parameter name line or l to avoid a name clash would have been better).</td>
              </tr>
              <tr>
                <td>08:53</td>
                <td>The str function converts any value to a string. We are only mapping over stings, so the strings
                  stay the same. To illustrate: (mapv str [“a” “b”]) returns [“a” “b”] and (mapv str [1 2 3]) returns
                  [“1” “2” “3”].</td>
              </tr>
              <tr>
                <td>09:06</td>
                <td>Now we implement the first half of the surrounding logic by only adding an underscore to the front
                  of the line l and removing all underscores in front of the strings we are mapping over. To do that, we
                  use the str-function. It can be called with an arbitrary number of arguments and returns a
                  concatenation of the string representation of all these arguments.</td>
              </tr>
              <tr>
                <td>09:17</td>
                <td>To complete the underscore-surrounding logic, we do the same with the underscores at the back.</td>
              </tr>
              <tr>
                <td>09:24</td>
                <td>We make the underscore-surrounding logic explicit by extracting a function for it.</td>
              </tr>
              <tr>
                <td>09:53</td>
                <td>At this point we notice, that the vector at line 23 that we are reducing over consists of the
                  middle-lines of (diamond \x), (diamond \y) and (diamond \z), given that the first letter of the
                  alphabet would be \x. That means, if we had a function middle-line that we could pass a character and
                  that would return the corresponding middle-line, our pyramid function would be close to completion. So
                  we use the todo function to formulate our wish for a middle-line function.</td>
              </tr>
              <tr>
                <td>10:41</td>
                <td>After writing down how to use the middle-line function, it gets obvious that the API of middle-line
                  is flawed. If (map middle-line [\x \y \z]) should result in [“x” “y_y” “z___z”], then that would also
                  mean that (middle-line \x) should result in “x”, while (middle-line \y) should result in “y_y”. Given
                  only one character as an argument, how should middle-line decide, how many underscore it should
                  return? We also have to pass the information, which character is supposed to be the first character of
                  the alphabet, which is the second character and so on. That is why we change the api of middle-line to
                  pass it the character as well as its index within an arbitrary alphabet. We call this sequence an
                  indexed-alphabet.</td>
              </tr>
              <tr>
                <td>10:56</td>
                <td>Instead of hard-coding the indexed-alphabet, we can generate it from the start and the end parameter
                  of the pyramid function. We formulate our wish for an indexed-alphabet function and start a new cycle
                  by making the indexed-alphabet function our new SUT.</td>
              </tr>
              <tr>
                <td>11:10</td>
                <td>Again, the first step in a new cycle according to the St. Pauli school of TDD is to write a simple
                  test at the API-level of the SUT before implementing the SUT. But this time we made a mistake by
                  naming the test identical to the SUT, which results in an error at 11:33</td>
              </tr>
              <tr>
                <td>11:33</td>
                <td>The SUT does not yet exist so we an expect an error. The next step is to write the definition of the
                  SUT. We expect to get rid of the error and get an assertion failure instead.</td>
              </tr>
              <tr>
                <td>11:43</td>
                <td>Because of the identical naming of the SUT and its test, the error does not disappear. Since we were
                  progressing with baby steps, we are faster by going back in time when we were in the green state and
                  redo the last step, instead of wondering or debugging, what we did wrong. In this way, we minimise the
                  time in the red state.</td>
              </tr>
              <tr>
                <td>11:52</td>
                <td>This time, we are naming the test correctly.</td>
              </tr>
              <tr>
                <td>12:19</td>
                <td>We are now getting the expected assertion failure, because we have not implemented indexed-alphabet,
                  yet. Therefore, we continue with the familiar triangulate-pattern.</td>
              </tr>
              <tr>
                <td>13:45</td>
                <td>vector is a function that can be called with arbitrary arguments and returns a vector containing all
                  the arguments. map-indexed is a function similar to map, except that it calls the mapping function
                  with 0 and the first element of the mapped collection, 1 and the second element, etc. By combining
                  both map-indexed and vector, we can replace the hard-coded [[0 \x][1 \y][2 \z]] with (map-indexed
                  vector [\x \y \z]).</td>
              </tr>
              <tr>
                <td>14:07</td>
                <td>The next step is to replace [\x \y \z] with something, that generates a character sequence beginning
                  with the start parameter, ending with the end parameter and all the necessary characters in between.
                  In Clojure, we can generate ranges of integer easily with (range start end). For example, (range 4 7)
                  returns (4 5 6). But range does not work with characters, that is why we prepare to convert a range of
                  integers to a range of characters. The first tiny step is to introduce the mapping by mapping over the
                  hard-coded vector with identity as the mapping function. As we used this technique before, we know
                  that this refactoring is safe and we will stay in the green state.</td>
              </tr>
              <tr>
                <td>14:16</td>
                <td>The char function converts an integer to a character and the int function converts a character to an
                  int. So we are changing the vector of chars to a vector of ints and map over it with the char
                  function. Applying both changes effectively compensate each other. The result is the exact same
                  sequence as before and all tests sill pass.</td>
              </tr>
              <tr>
                <td>14:35</td>
                <td>With all the transformation in place, we can now replace the vector with a call to range, which only
                  needs the start and the end, not any elements in the middle.</td>
              </tr>
              <tr>
                <td>14:49</td>
                <td>In contrast to our expectation, the test fails and informs us, that [[0 \x] [1 \y] [2 \z]] is not
                  equal to [[0 \x] [1 \y]]. We made an off-by-one-error apparently.</td>
              </tr>
              <tr>
                <td>14:50</td>
                <td>(range start end) creates a sequence including start, but excluding end. So to include end in our
                  sequence, we need to increment end by one by calling (inc end)</td>
              </tr>
              <tr>
                <td>14:53</td>
                <td>Now we can replace the hard-coded characters with the start and end parameters of the the
                  indexed-alphabet function.</td>
              </tr>
              <tr>
                <td>15:04</td>
                <td>And now we can remove the hard-coded branches for when end equals \y and end equals \x. After that,
                  we can also remove the cond-macro.</td>
              </tr>
              <tr>
                <td>15:27</td>
                <td>Only now do we complete our first St. Pauli TDD cycle by finish off with a validation test that is
                  structurally different to the previous test data. This is helpful to avoid overfitting to the training
                  set we used to drive the implementation.</td>
              </tr>
              <tr>
                <td>16:02</td>
                <td>We start the next St. Pauli TDD cycle by writing a test for the middle-line function.</td>
              </tr>
              <tr>
                <td>16:23</td>
                <td>The definition of the middle-line function makes use of destructuring. This is a technique to assign
                  names to elements of a collection parameter. As formulated in the tests, the API of the middle-line
                  function expects a vector as the single argument, representing one element of an indexed alphabet. The
                  first element of that vector is the index within the alphabet, so we assign the name index to that
                  element. The second element is the actual character which we assign the name $char (again, the prefix
                  $ is just there to avoid a name collision with the function char).</td>
              </tr>
              <tr>
                <td>16:37</td>
                <td>We continue again with the triangulate-pattern.</td>
              </tr>
              <tr>
                <td>17:52</td>
                <td>After three examples we see that all middle lines for characters with an index larger 0 have a
                  similar structure. We do not think that any additional examples would lead to any more insight.
                  Instead we notice, that the middle line string consists of three parts: For all characters with an
                  index larger than 0, the first and the last part are always the same and only the middle part changes
                  dynamically depending on the input. Hence we use tiny baby-steps to split the string in three parts.
                </td>
              </tr>
              <tr>
                <td>18:11</td>
                <td>This structure resembles our surround-logic, except that we do not surround the middle part with
                  underscores but with the $char parameter instead. Since our surround function can only surround values
                  with underscores, we enhance it so that it can surround a value with arbitrary values. We do not write
                  a test for that enhancement because we feel confident that we can simply write the correct
                  implementation in short time. This approach is called “Obvious Implementation”. As a rule of thumb, we
                  only use this pattern when writing the real implementation is faster than an average TDD cycle.</td>
              </tr>
              <tr>
                <td>19:10</td>
                <td>Now we dedicate to the dynamic part of the middle line. We notice a pattern in how the middle-line
                  is created depending on the arguments. If the index is 0, the middle-line is simple the character. If
                  the index is 1, one underscore is surrounded by zero additional underscores and the input character.
                  If the index is 2, one underscore is surrounded by underscores once and the input character. If the
                  index is 3, one underscore is surrounded by underscores twice and the input character. The else-case
                  describes to this point only the behaviour when index is 2. That means, if we surround an underscore
                  with underscores once, we get the same result as the hard-coded “___” string.</td>
              </tr>
              <tr>
                <td>19:18</td>
                <td>At this point we introduce two more functions. first takes a collection as argument and returns the
                  first element of that collection: (first [3 4 5]) returns 3. An alternative to first is to use the nth
                  function and call it with the collection and the index of 0: (nth [3 4 5] 0) return 3. iterate takes a
                  mapping function and an initial value and returns an infinite sequence that starts with the initial
                  value and whose consecutive values are the mapping function applied to the previous element of the
                  sequence: (first (iterate inc 0)) returns 0 and (nth (iterate inc 50) 3) returns 53. Since (first
                  (iterate surround “_")) returns “_”, we can replace the hard-coded string with this expression without
                  changing any visible behaviour.</td>
              </tr>
              <tr>
                <td>19:29</td>
                <td>In line 34, we reference the surround-function three times: The first call is to surround the
                  underscores with the input character. This is different to the next two references of the surround
                  functions. These are called to generate the underscore string with variable length. We notice that we
                  can remove the duplication of calling surround twice by replacing (surround (first (iterate surround
                  "_"))) with (second (iterate surround "_”)) which is equivalent to (nth (iterate surround "_") 1)</td>
              </tr>
              <tr>
                <td>19:57</td>
                <td>We also notice, that the nth element is dependent of the index of the input character. We can
                  replace the hard-coded 1 with decrementing the index by 1 via the built-in dec-function.</td>
              </tr>
              <tr>
                <td>20:08</td>
                <td>Now it is time to remove the hard-coded “x” with the input character.</td>
              </tr>
              <tr>
                <td>20:14</td>
                <td>After that, our else-case can also handle the case when the index equals 1, so we can delete line
                  33.</td>
              </tr>
              <tr>
                <td>20:19</td>
                <td>We can replace the last hard-coded value in line 32 with the input character converted to a string.
                </td>
              </tr>
              <tr>
                <td>20:28</td>
                <td>The branching can be simplified by replacing the cond-macro with a simple if.</td>
              </tr>
              <tr>
                <td>20:36</td>
                <td>The condition can also be simplified by only checking whether the index is positive.</td>
              </tr>
              <tr>
                <td>21:09</td>
                <td>We finish the current St. Pauli TDD cycle for middle-line by adding a validation test.</td>
              </tr>
              <tr>
                <td>21:28</td>
                <td>Because we successfully finished the last SUT, we search for references of “todo” to check if we can
                  resolve now the todo and delegate to the real implementation. We find two references: In line 72 we
                  wrap the call to the pyramid-function with the todo-function. We cannot resolve this reference,
                  because pyramid itself is also using the todo-function. Even if we forgot, that the St. Pauli TDD
                  cycle for the pyramid-function is not completed, we would know by now. The second reference is at line
                  50. Because both middle-line and indexed-alphabet have completed their St. Pauli TDD cycle, we can
                  replace the todo-wrapper and just call the real implementation.</td>
              </tr>
              <tr>
                <td>21:55</td>
                <td>The else-case in line 47 can now also handle all other cases so we can remove line 45 and line 46.
                  As soon as there is no branching anymore, we can remove the cond-macro altogether.</td>
              </tr>
              <tr>
                <td>22:07</td>
                <td>In hindsight, this refactoring was questionable, because the parameter name “line” does not longer
                  fit. In line 46 we are now calling (middle-line line). This does not make sense, because the
                  middle-line expects to be called with a pair of index and character and not with a line.</td>
              </tr>
              <tr>
                <td>22:29</td>
                <td>After adding a validation test, we can now finish the current St. Pauli TDD cycle for the
                  pyramid-function. Again, we make sure that the test data is as different as possible to the previous
                  test data.</td>
              </tr>
              <tr>
                <td>23:25</td>
                <td>Now we can remove the last todo-reference. Thanks to our tests, we know at this point how to call
                  the pyramid function. One could argue that we violated YAGNI since our diamond-function always starts
                  with the \a character but the pyramid function is able to generate pyramids that start with arbitrary
                  characters. On the other hand, this design reveals on the highest abstraction level, that the diamonds
                  always start with the \a character. If we formulated this restriction within the pyramid function, it
                  would have been buried one abstraction lever deeper in the code. One could also argue with the Single
                  Responsibility Principle: If we change the starting character of a diamond to a capital A, not only
                  the diamonds-tests would break but also the pyramid-tests. There are more arguments whether one design
                  is better than the other, but in conclusion, both decisions would be ok.</td>
              </tr>
              <tr>
                <td>23:46</td>
                <td>Our else-case can now also handle all other cases, so we can remove the cond-macro.</td>
              </tr>
              <tr>
                <td>24:01</td>
                <td>Approaching the end of the kata, we group test and production code together.</td>
              </tr>
              <tr>
                <td>24:25</td>
                <td>Now we complete the final St. Pauli TDD cycle and make sure we really completed the kata by adding
                  the final validation test at the API-level.</td>
              </tr>
              <tr>
                <td>24:55</td>
                <td>All tests pass. We do not need the todo-function anymore so we remove it. Congratulation, we
                  completed the Diamond-Kata!</td>
              </tr>

            </tbody>
          </table>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <h2 id="faq">FAQ</h2>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <h4>Why another school? Don't we have enough already?</h4>
        <p scope="row">The St. Pauli school of TDD started as a tongue-in-cheek response to the new founded
          <a href="https://de.slideshare.net/davidvoelkel/fake-it-outsidein-tdd-xp2017">Munich school of TDD</a>
          by fellow software crafter <a href="https://twitter.com/davidvoelkel">David
            Völkel</a>, but developed in a useful TDD style of its own.</p>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <h4>Isn't TDD a waste of time, since there are so much better development techniques out there?</h4>
        <p scope="row">Even though <a
            href="https://web.archive.org/web/20170621004437/http://alistair.cockburn.us/Thinking+before+programming">Thinking
            before programming</a>,
          <a href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/HammockDrivenDev.md">Hammock-driven
            Development</a>, <a href="https://jqwik.net/property-based-testing.html">Property-Based Testing</a>,
          <a href="https://github.com/matthiasn/talk-transcripts/blob/master/Halloway_Stuart/REPLDrivenDevelopment.md">REPL-Driven
            development</a> and <a href="https://blog.ploeh.dk/2015/08/10/type-driven-development/">Type-driven
            Development</a> are useful techniques, this does neither imply that TDD is useless, nor that the
          aforementioned techniques and Test-driven Development are mutually exclusive.</p>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <h4>Were can I find the source code of the demo?</h4>
        <p scope="row">The code is on <a
            href="https://gist.github.com/lomin/e64af7828badac1562942d888068cabc">GitHub</a>.</p>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <h2 id="sponsor">Sponsor</h2>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12">
        <a href="https://www.it-agile.de" title="Die Experten für agile Methoden"><img
            src="https://www.it-agile.de/typo3conf/ext/tmpl_base/Resources/Public/Images/it-agile-Logo.svg"
            alt="it-agile Logo"></a>
      </div>
    </div>

    <footer id="footer">
      <a class="float-lg-right" href="#top">Back to top</a>
    </footer>

  </div>
  <script src="js/asciinema-player.js"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
    integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
    crossorigin="anonymous"></script>
</body>

</html>